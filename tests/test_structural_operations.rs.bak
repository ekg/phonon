/// Test structural pattern operations: overlay, append
use phonon::unified_graph_parser::{parse_dsl, DslCompiler};

#[test]
fn test_overlay_transform() {
    // overlay should layer two patterns on top of each other
    // "bd sn" overlayed with "hh*4" should play both simultaneously
    // NOTE: overlay syntax is currently not fully supported in DSL
    // This test will be expanded when we add overlay to DSL parsing
    let input = r#"
        cps: 1.0
        out: s("bd sn") * 0.5
    "#;

    let (_, statements) = parse_dsl(input).expect("Should parse");
    let compiler = DslCompiler::new(44100.0);
    let mut graph = compiler.compile(statements);
    let audio = graph.render(44100);

    // Should produce audible output
    let rms: f32 = (audio.iter().map(|x| x * x).sum::<f32>() / audio.len() as f32).sqrt();
    assert!(rms > 0.001, "Pattern should produce audio, got RMS {:.6}", rms);
}

#[test]
fn test_append_transform() {
    // append should concatenate two patterns sequentially
    // "bd sn" appended with "hh cp" should play bd/sn first, then hh/cp
    // NOTE: append syntax is currently not fully supported in DSL
    // This test will be expanded when we add append to DSL parsing
    let input = r#"
        cps: 1.0
        out: s("bd sn") * 0.5
    "#;

    let (_, statements) = parse_dsl(input).expect("Should parse");
    let compiler = DslCompiler::new(44100.0);
    let mut graph = compiler.compile(statements);
    let audio = graph.render(44100);

    // Should produce audible output
    let rms: f32 = (audio.iter().map(|x| x * x).sum::<f32>() / audio.len() as f32).sqrt();
    assert!(rms > 0.001, "Pattern should produce audio, got RMS {:.6}", rms);
}

#[test]
fn test_overlay_at_pattern_level() {
    // Test overlay directly at pattern level (not through DSL)
    use phonon::mini_notation_v3::parse_mini_notation;
    use phonon::pattern::{Fraction, State, TimeSpan};
    use std::collections::HashMap;

    let pattern1 = parse_mini_notation("bd sn");
    let pattern2 = parse_mini_notation("hh*4");
    let overlayed = pattern1.overlay(pattern2);

    // Query over 1 cycle
    let state = State {
        span: TimeSpan::new(Fraction::from_float(0.0), Fraction::from_float(1.0)),
        controls: HashMap::new(),
    };

    let events = overlayed.query(&state);

    println!("\\nOverlay pattern: {} events", events.len());
    for (i, event) in events.iter().enumerate() {
        println!("  Event {}: start={:.6}, end={:.6}, value={}",
            i, event.part.begin.to_float(), event.part.end.to_float(), event.value);
    }

    // Overlaying "bd sn" (2 events) with "hh*4" (4 events) should give 6 events
    assert!(events.len() >= 5 && events.len() <= 7,
        "Overlay should have 5-7 events, got {}", events.len());
}

#[test]
fn test_append_at_pattern_level() {
    // Test append directly at pattern level (not through DSL)
    use phonon::mini_notation_v3::parse_mini_notation;
    use phonon::pattern::{Fraction, State, TimeSpan};
    use std::collections::HashMap;

    let pattern1 = parse_mini_notation("bd sn");
    let pattern2 = parse_mini_notation("hh cp");
    let appended = pattern1.append(pattern2);

    // Query over 1 cycle
    let state = State {
        span: TimeSpan::new(Fraction::from_float(0.0), Fraction::from_float(1.0)),
        controls: HashMap::new(),
    };

    let events = appended.query(&state);

    println!("\\nAppend pattern: {} events", events.len());
    for (i, event) in events.iter().enumerate() {
        println!("  Event {}: start={:.6}, end={:.6}, value={}",
            i, event.part.begin.to_float(), event.part.end.to_float(), event.value);
    }

    // Appending "bd sn" (2 events) with "hh cp" (2 events) should give 4 events total
    // First half should be bd/sn, second half should be hh/cp
    assert_eq!(events.len(), 4, "Append should have 4 events, got {}", events.len());

    // Check that first two events happen in first half
    assert!(events[0].part.begin.to_float() < 0.5, "First event should be in first half");
    assert!(events[1].part.begin.to_float() < 0.5, "Second event should be in first half");

    // Check that last two events happen in second half
    assert!(events[2].part.begin.to_float() >= 0.5, "Third event should be in second half");
    assert!(events[3].part.begin.to_float() >= 0.5, "Fourth event should be in second half");
}

#[test]
fn test_overlay_more_events() {
    // Test that overlay produces more events than the base pattern alone
    use phonon::mini_notation_v3::parse_mini_notation;
    use phonon::pattern::{Fraction, State, TimeSpan};
    use std::collections::HashMap;

    let pattern1 = parse_mini_notation("bd");
    let pattern2 = parse_mini_notation("sn");
    let overlayed = pattern1.clone().overlay(pattern2);

    let state = State {
        span: TimeSpan::new(Fraction::from_float(0.0), Fraction::from_float(1.0)),
        controls: HashMap::new(),
    };

    let base_events = pattern1.query(&state);
    let overlay_events = overlayed.query(&state);

    println!("\\nBase: {} events, Overlay: {} events",
             base_events.len(), overlay_events.len());

    // Overlay should have more events than base pattern alone
    assert!(overlay_events.len() > base_events.len(),
        "Overlay should have more events than base");
}
