/// Band-limited impulse train (anti-aliased clicks/impulses)
///
/// This node generates band-limited impulses using differentiation of a
/// band-limited saw wave. Unlike naive impulse trains which alias badly,
/// the blip uses PolyBLEP to create smooth transitions without aliasing.
///
/// This is ideal for:
/// - Triggering envelopes without aliasing
/// - Percussion synthesis (clicks, pops)
/// - Physical modeling (Karplus-Strong, modal synthesis)
/// - Any application requiring clean impulses
///
/// # Algorithm
///
/// The blip is generated by differentiating a band-limited saw wave:
/// 1. Generate saw wave with PolyBLEP anti-aliasing
/// 2. Differentiate (current sample - previous sample)
/// 3. Result: band-limited impulse train
///
/// # References
///
/// - Julius O. Smith "Spectral Audio Signal Processing" (2011)
/// - Stilson/Smith "Antialiasing Oscillators" (1996)
/// - PolyBLEP: polynomial bandlimited step function

use crate::audio_node::{AudioNode, NodeId, ProcessContext};

/// Band-limited impulse train generator
///
/// Produces impulses at frequency-controlled intervals with no aliasing.
/// The impulses are generated by differentiating a band-limited saw wave,
/// resulting in clean clicks suitable for triggering envelopes or percussion.
///
/// # Example
/// ```ignore
/// // 1 Hz band-limited impulse train
/// let freq_const = ConstantNode::new(1.0);  // NodeId 0
/// let blip = BlipNode::new(0);              // NodeId 1
/// ```
pub struct BlipNode {
    freq_input: NodeId,  // NodeId providing frequency values
    phase: f32,          // Internal state (0.0 to 1.0)
    last_saw: f32,       // Previous saw sample for differentiation
}

impl BlipNode {
    /// Create a new band-limited impulse generator node
    ///
    /// # Arguments
    /// * `freq_input` - NodeId that provides frequency (can be constant or pattern)
    pub fn new(freq_input: NodeId) -> Self {
        Self {
            freq_input,
            phase: 0.0,
            last_saw: 0.0,
        }
    }

    /// Get current phase (0.0 to 1.0)
    pub fn phase(&self) -> f32 {
        self.phase
    }

    /// Reset phase to 0.0 and clear last saw value
    pub fn reset_phase(&mut self) {
        self.phase = 0.0;
        self.last_saw = 0.0;
    }
}

/// PolyBLEP (Polynomial Bandlimited Step) function
///
/// Generates a correction signal that removes aliasing from discontinuities.
/// This is applied at phase wrap points to smooth the transition.
///
/// # Arguments
/// * `t` - Current phase (0.0 to 1.0)
/// * `dt` - Phase increment per sample (freq / sample_rate)
///
/// # Returns
/// Correction value to subtract from naive waveform
fn poly_blep(t: f32, dt: f32) -> f32 {
    if t < dt {
        // Rising edge (phase near 0.0)
        let t = t / dt;
        2.0 * t - t * t - 1.0
    } else if t > 1.0 - dt {
        // Falling edge (phase near 1.0)
        let t = (t - 1.0) / dt;
        t * t + 2.0 * t + 1.0
    } else {
        // Middle of waveform, no correction needed
        0.0
    }
}

impl AudioNode for BlipNode {
    fn process_block(
        &mut self,
        inputs: &[&[f32]],
        output: &mut [f32],
        sample_rate: f32,
        _context: &ProcessContext,
    ) {
        debug_assert!(
            !inputs.is_empty(),
            "BlipNode requires frequency input"
        );

        let freq_buffer = inputs[0];

        debug_assert_eq!(
            freq_buffer.len(),
            output.len(),
            "Frequency buffer length mismatch"
        );

        for i in 0..output.len() {
            let freq = freq_buffer[i];
            let phase_increment = freq / sample_rate;

            // Generate band-limited saw wave using PolyBLEP
            let saw = 2.0 * self.phase - 1.0;  // Naive saw: -1 to +1
            let saw_corrected = saw - poly_blep(self.phase, phase_increment);

            // Differentiate to get band-limited impulse
            // The derivative of a saw wave is an impulse train
            let blip = saw_corrected - self.last_saw;

            // Store for next iteration
            self.last_saw = saw_corrected;

            // Output the band-limited impulse
            output[i] = blip;

            // Advance phase
            self.phase += phase_increment;

            // Wrap phase to [0.0, 1.0)
            while self.phase >= 1.0 {
                self.phase -= 1.0;
            }

            // Handle negative frequencies (wrap backwards)
            while self.phase < 0.0 {
                self.phase += 1.0;
            }
        }
    }

    fn input_nodes(&self) -> Vec<NodeId> {
        vec![self.freq_input]
    }

    fn name(&self) -> &str {
        "BlipNode"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nodes::constant::ConstantNode;
    use crate::pattern::Fraction;

    #[test]
    fn test_blip_generates_impulses() {
        // Blip should generate periodic impulses
        let mut const_freq = ConstantNode::new(1.0);  // 1 Hz
        let mut blip = BlipNode::new(0);

        let buffer_size = 48510;  // 1.1 seconds at 44100 Hz
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        // Generate frequency buffer
        let mut freq_buf = vec![0.0; buffer_size];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        // Generate blip output
        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Should have significant energy (not all zeros)
        let has_energy = output.iter().any(|&x| x.abs() > 0.5);
        assert!(has_energy, "Blip should generate significant impulses");
    }

    #[test]
    fn test_blip_at_440hz() {
        // Test at audio rate frequency
        let mut const_freq = ConstantNode::new(440.0);
        let mut blip = BlipNode::new(0);

        let buffer_size = 44100;  // 1 second
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        let mut freq_buf = vec![0.0; buffer_size];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Should generate audio-rate impulses
        let has_energy = output.iter().any(|&x| x.abs() > 0.1);
        assert!(has_energy, "Blip at 440 Hz should generate impulses");
    }

    #[test]
    fn test_blip_frequency_modulation() {
        // Test with varying frequency
        let mut blip = BlipNode::new(0);

        let buffer_size = 1024;
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        // Create frequency sweep from 100 Hz to 1000 Hz
        let mut freq_buf = vec![0.0; buffer_size];
        for i in 0..buffer_size {
            let t = i as f32 / buffer_size as f32;
            freq_buf[i] = 100.0 + 900.0 * t;  // Linear sweep
        }

        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Should track frequency modulation
        let has_energy = output.iter().any(|&x| x.abs() > 0.1);
        assert!(has_energy, "Blip should follow frequency modulation");
    }

    #[test]
    fn test_blip_no_dc_offset() {
        // Band-limited impulse train should average to zero
        let mut const_freq = ConstantNode::new(100.0);
        let mut blip = BlipNode::new(0);

        let buffer_size = 44100;  // 1 second
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        let mut freq_buf = vec![0.0; buffer_size];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Calculate DC offset (mean)
        let sum: f32 = output.iter().sum();
        let mean = sum / output.len() as f32;

        // DC offset should be very small (near zero)
        assert!(
            mean.abs() < 0.01,
            "Blip should have minimal DC offset, got {}",
            mean
        );
    }

    #[test]
    fn test_blip_impulse_spacing() {
        // At 10 Hz, impulses should be ~4410 samples apart
        let mut const_freq = ConstantNode::new(10.0);
        let mut blip = BlipNode::new(0);

        let buffer_size = 44100;  // 1 second
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        let mut freq_buf = vec![0.0; buffer_size];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Find peak groups (each impulse may span multiple samples)
        // Count distinct impulse events by finding local maxima
        let mut impulse_count = 0;
        let mut in_impulse = false;
        let threshold = 0.5;

        for i in 0..output.len() {
            if output[i].abs() > threshold {
                if !in_impulse {
                    impulse_count += 1;
                    in_impulse = true;
                }
            } else {
                in_impulse = false;
            }
        }

        // Should have around 10 impulse events at 10 Hz over 1 second
        assert!(
            impulse_count >= 8 && impulse_count <= 12,
            "Expected ~10 impulses at 10 Hz, got {}",
            impulse_count
        );
    }

    #[test]
    fn test_blip_amplitude_range() {
        // Check that blip output stays in reasonable range
        let mut const_freq = ConstantNode::new(440.0);
        let mut blip = BlipNode::new(0);

        let buffer_size = 44100;
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        let mut freq_buf = vec![0.0; buffer_size];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Find max absolute value
        let max_abs = output.iter().map(|x| x.abs()).fold(0.0f32, f32::max);

        // Blip peaks should be significant but not excessive
        // Differentiated saw can have peaks around 2.0
        assert!(
            max_abs > 0.1,
            "Blip should have significant amplitude, got {}",
            max_abs
        );
        assert!(
            max_abs < 10.0,
            "Blip amplitude should be reasonable, got {}",
            max_abs
        );
    }

    #[test]
    fn test_blip_phase_wrapping() {
        let mut blip = BlipNode::new(0);

        // Set phase close to 1.0
        blip.phase = 0.99;

        let freq_buf = vec![441.0];  // ~1% of sample rate
        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; 1];

        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            1,
            2.0,
            44100.0,
        );

        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Phase should wrap back to [0.0, 1.0)
        assert!(
            blip.phase() >= 0.0 && blip.phase() < 1.0,
            "Phase didn't wrap: {}",
            blip.phase()
        );
    }

    #[test]
    fn test_blip_input_nodes() {
        let blip = BlipNode::new(42);
        let deps = blip.input_nodes();

        assert_eq!(deps.len(), 1);
        assert_eq!(deps[0], 42);
    }

    #[test]
    fn test_blip_state_isolation() {
        // Two separate blip nodes should have independent state
        let mut blip1 = BlipNode::new(0);
        let mut blip2 = BlipNode::new(0);

        // Generate with first blip (advances phase)
        let mut const_freq = ConstantNode::new(440.0);
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            1024,
            2.0,
            44100.0,
        );

        let mut freq_buf = vec![0.0; 1024];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        let inputs = vec![freq_buf.as_slice()];
        let mut output1 = vec![0.0; 1024];
        blip1.process_block(&inputs, &mut output1, 44100.0, &context);

        // Second blip should start from phase 0
        let mut output2 = vec![0.0; 1024];
        blip2.process_block(&inputs, &mut output2, 44100.0, &context);

        // First few samples should be identical (same starting phase)
        assert_eq!(
            output1[0], output2[0],
            "Independent blip nodes should produce same initial output"
        );
    }

    #[test]
    fn test_blip_reset_phase() {
        let mut blip = BlipNode::new(0);

        // Advance phase
        blip.phase = 0.5;
        blip.last_saw = 0.3;

        // Reset
        blip.reset_phase();

        assert_eq!(blip.phase(), 0.0, "Phase should reset to 0.0");
        assert_eq!(blip.last_saw, 0.0, "Last saw should reset to 0.0");
    }

    #[test]
    fn test_blip_low_frequency() {
        // Test at very low frequency (0.5 Hz)
        let mut const_freq = ConstantNode::new(0.5);
        let mut blip = BlipNode::new(0);

        let buffer_size = 44100;  // 1 second
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        let mut freq_buf = vec![0.0; buffer_size];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Should have energy even at low frequency
        let has_energy = output.iter().any(|&x| x.abs() > 0.1);
        assert!(has_energy, "Blip should work at low frequencies");
    }

    #[test]
    fn test_blip_polyblep_reduces_aliasing() {
        // This test verifies that PolyBLEP is being applied
        // by checking that the output is smoother than a naive impulse
        let mut const_freq = ConstantNode::new(8000.0);  // High frequency
        let mut blip = BlipNode::new(0);

        let buffer_size = 1024;
        let context = ProcessContext::new(
            Fraction::from_float(0.0),
            0,
            buffer_size,
            2.0,
            44100.0,
        );

        let mut freq_buf = vec![0.0; buffer_size];
        const_freq.process_block(&[], &mut freq_buf, 44100.0, &context);

        let inputs = vec![freq_buf.as_slice()];
        let mut output = vec![0.0; buffer_size];
        blip.process_block(&inputs, &mut output, 44100.0, &context);

        // Band-limited output should not have extreme discontinuities
        // Check that consecutive samples don't jump too wildly
        let mut max_jump = 0.0f32;
        for i in 1..output.len() {
            let jump = (output[i] - output[i - 1]).abs();
            max_jump = max_jump.max(jump);
        }

        // PolyBLEP should smooth transitions somewhat
        // (This is a weak test, but verifies the algorithm is running)
        assert!(
            max_jump < 20.0,
            "PolyBLEP should limit discontinuities, max jump: {}",
            max_jump
        );
    }

    #[test]
    fn test_blip_name() {
        let blip = BlipNode::new(0);
        assert_eq!(blip.name(), "BlipNode");
    }
}
